{"title": "APIScanner - Towards Automated Detection of Deprecated APIs in Python Libraries", "abstract": "-Python libraries are widely used for machine learn20 itanhrgee asdanemdpersecwcieaantyetidfiacsdciunoemotptohuetfrienalgatuntargesukaesgntehosad.naTcyh.eemAsePenIdstesipnarPnecdyatthbeoudngAlifiPbxIresasrairienes y discouraged from being used in further software development. a Manually detecting and replacing deprecated APIs is a tedious and time-consuming task due to the large number of API calls Mused in the projects. Moreover, the lack of proper documentation 0 for these deprecated APIs makes the task challenging. To address 1 this challenge, we propose an algorithm and a tool APIScanner that automatically detects deprecated APIs in Python libraries. ] This algorithm parses the source code of the libraries using Eabstract syntax tree (ASTs) and identifies the deprecated APIs S via decorator, hard-coded warning or comments. APIScanner is</p>", "-": "\n        [ the source code. The tool can help developers to avoid using\ndeprecated API elements without the execution of code. We tested\n4 our algorithm and tool on six popular Python libraries, which\ndev tected 838 of 871 deprecated API elements. Demo of APIScanner:\n1 https://youtu.be/1hy ugf-iek. Documentation, tool, and source\n5 code can be found here: https://rishitha957.github.io/APIScanner.\n2\n9 Index Terms?Deprecated APIs, Python Libraries, API\nEvolu.0 tion, Visual Studio Code Extension\n02 I. INTRODUCTION\n1 Python is one of the popular dynamic programming\nlan:2 guage that has gained immense popularity due to its extensive\nv collection of libraries, including popular modules for machine\ni learning and scientific computing 1. Due to reasons such\nrXas feature improvements and bug repairs, python libraries\na are frequently updated. Most API changes include moving\nmethods or fields around and renaming or changing method\nsignatures [\n        \n        ]. These changes may induce compatibility\nissues in client projects [\n        \n        ]. It is recommended to follow the\ndeprecate-replace-remove cycle to enable developers to adapt\nto these changes smoothly[\n        \n        ]. In this process, APIs that are no\nlonger supported are first labeled as deprecated, and then the\ndeprecated APIs are replaced with their substitution messages\nto help developers transition from deprecated APIs to new\nones [\n        \n        ]. The deprecated APIs are gradually removed from\nthe library in future releases. Unfortunately, this process is\nnot always followed, as discovered by several studies [\n        \n        ], [\n        \n        ],\n      ", "1https://www.tiobe.com/tiobe-index/": "\n        making it difficult for both library maintainers and developers.\nKo et al. have analyzed the quality of documentation for\nresolving deprecated APIs [\n        \n        ]. Researchers have proposed\ntechniques to automatically update deprecated APIs [\n        \n        ], [\n        \n        ].\nHowever, most of them are for static programming languages\nsuch as Java, C# and Android SDKs. Python being a typical\ndynamic programming language, exhibits different API\nevolution patterns compared to Java [\n        \n        ]. Hence it motivates the\nneed for new techniques and tools to detect deprecated APIs.\n      \n        Deprecated APIs in Python libraries are mainly declared by\ndecorator, hard-coded warning, and comments [\n        \n        ].\nNevertheless, it was discovered that library maintainers use varied\nand multiple strategies for API deprecation, leading to\ninconsistency in the implementation of libraries as well as their\nautomated detection [\n        \n        ]. In addition, nearly one-third of the\ndeprecated APIs in Python is not included in the official library\ndocumentation, making it hard for developers using libraries\nto limit the use of deprecated APIs [\n        \n        ].\n      \n        To avoid the usage of deprecated APIs during new software\ndevelopment, developers should be aware of deprecating APIs\nin the project, motivating the need for this research. Hence,\ngiven the rise in popularity of Python and the number of\ndeprecated APIs used in Python projects, we propose a novel\nalgorithm that uses the source code of the Python libraries\nto get a list of deprecated APIs. This list is further used\nto detect deprecated APIs in Python projects. This paper\ncontributes (i) an algorithm for deprecated API detection\nand (ii) a Visual Studio Code extension, APIScanner2. We\nbelieve that APIScanner might assist developers to detect\ndeprecated APIs and help them avoid searching through API\ndocumentation or on forums such as Stack Overflow. As a\npreliminary evaluation, we tested our algorithm and tool on\nsix popular Python libraries [\n        \n        ] that are commonly used in\ndata analytics, machine learning, and scientific computing.\nThe initial results are promising with 90% API deprecation\ndetection, with potential for application beyond these libraries.\n      ", "II. APPROACH": "\n        Wang et al. [\n        \n        ] investigated that inconsistency in the\nadopted deprecation strategies makes it a harder task to use\n2https://marketplace.visualstudio.com/items?itemName=Rishitha.\napiscanner\nFig. 1. Approach for Detecting Deprecated API Elements in Python Libraries\nautomated approaches for managing deprecated APIs and their\ndocumentation. In this paper, we propose an approach (as\nshown in Fig. 1) to automatically detect deprecated APIs in\nPython libraries and alert developers during API usage in\nsoftware development. Firstly, we identify the libraries used in\nthe client code from import statements. We build an abstract\nsyntax tree (AST) to parse the source code to detect the\npatterns. The proposed Algorithm 1 is then applied on the\nASTs to retrieve a list of deprecated APIs in those libraries.\nBased on this list, APIScanner parses each line of code in\nthe editor, highlights the deprecated elements in the editor.\nOn hovering, the tool also displays a message informing the\ndeveloper that some element(s) of this API call has been\ndeprecated (as shown in Fig. 2). We developed APIScanner\nas a Visual Studio Code extension as it supports both Python\nscripts and jupyter notebooks3.\n(a) Using Decorator: in Matplotlib\n@_api.deprecated(\"3.3\", alternative=\"Glue(?fil?)\")\nclass Fil(Glue):\ndef __init__(self):\n      super().__init__(?fil?)\n(b) Using Comments: in Sklearn\nclass GradientBoostingClassifier(args):\n\"\"\"\n..criterion : {?friedman_mse?, ?mse?, ?mae?}..\n.. deprecated:: 0.24 ?criterion=?mae?? is deprecated and will be removed in\nversion 0.26. Use ?criterion=?friedman_mse?? or ??mse?? instead, as trees\nshould use a least-square criterion in Gradient Boosting\n\"\"\"\n(c) Using Hardcoded Warnings: in Pandas\nclass Series(args):\ndef __init__(self,args):\nif dtype is None:warnings.warn(\"The default dtype for empty Series will be ?object?\ninstead of ?float64? in a future version\",DeprecationWarning,stacklevel=2)\nListing 1. Examples of methods of deprecation strategies adopted in Python\nlibraries which are deprecated through a) decorator, b) comments c)\nhardcoded warning\nA. Detecting Deprecated API Elements through Source CodeWe parse the source code of the library to generate an AST\nand denote it as PAST . Examples of Python APIs deprecated\nby decorator, hard-coded warnings, and comments are shown\nin listing 1. Structure of AST helps to realize the relationship\nbetween class declaration and function definition with\ndecorator, hard-coded warnings, and comments. We traverse through\neach node NAST in the AST and generate PAST using\nDepthFirst Search (cf. Line-2). Whenever we encounter a class\ndefinition node, we extract the doc-string of that particular\nclass. If the doc-string contains the deprecate keyword (such\nas (b) in Listing 1), we generate the Fully Qualified API name\nof the class by appending the class name to the directory path.\nWe also append the deprecation message to LD (cf. Line-13)\nalong with a list of decorators associated with the class. If\nthere is a deprecated decorator (such as (a) in Listing 1) in the\nextracted list, we add the fully qualified name of the class and\nany description provided to list LD (cf. Line-16). Similarly,\nwhen we encounter the function definition node, we extract the\nlist of decorators associated with it. If there is a deprecated\ndecorator in the extracted list, we add a fully qualified name\nof the function to list LD (cf. Line-6). For each function call\nnode in NAST (cf. Line-7), we verify if DeprecationWarning\nor FutureWarning are passed as arguments (such as (c) in\nListing 1) and add its fully qualified name to list LD, which\nis the final generated list of deprecated API elements.", "III. EVALUATION": "A. Libraries Selection\n        To evaluate our approach, we applied it on six popular\nthirdparty Python libraries that were identified by Pimentel et al\n[\n        \n        ]. However, this approach is not limited to the selected\nlibraries and could be applied to other Python libraries as well.\n      \n        NumPy: Array programming library [\n        \n        ].\n      \n        Matplotlib: A 2D graphics environment [\n        \n        ].\n      \n        Pandas: Data analysis and manipulation tool [\n        \n        ].\nScikit-learn: Machine learning library for Python [\n        \n        ].\nScipy: Library for scientific and technical computing [\n        \n        ].\nSeaborn: Data visualization based on matplotlib [\n        \n        ].\nAlgorithm 1: Detecting Deprecated API Elements in\nPython Libraries\nInput: P , Python Library Code\n      Output: LD, List of Deprecated API Elements\n1 Function Detect_Deprecated_API():\n2 LD fg\n/* parseCode returns Abstract syntax tree of\ngiven code input */\n3 PAST parseCode(P )/* Traverse each node in PAST using BFS */\n4 for NAST 2 PAST do\n5 if isFunctionDefNode(NAST ) then\n6 D = NAST :Decorators\n7 if isDeprecatedDecorator(D) then\n8 LD.add(getFullyQualifiedName(NAST :Name))\n/* Traverse each Node in NAST */\n9 for Node 2 NAST do\n10 if isFunctionCallNode(Node) andisDeprecationWarning(Node) then\n11 LD.add(getFullyQualifiedName(NAST :Name))Table I summarizes the total number of deprecated API\nelements detected by the Algorithm 1 and the total number\nof deprecated API elements found in the source code of\nthe Python libraries. We manually counted the number of\ndeprecated API elements present in the source code of the\nlibraries. From Table I, we can observe that the algorithm has\ndetected more than 90% of the deprecated APIs. In the case of\nMatplotlib, only 65% of the deprecated APIs could be detected\nsince Matplotlib deprecates many of its parameters using a\ncustom warning function which does not have any parameters\nindicating if it is a DeprecationWarning or not. In such cases,\nthe proposed algorithm could not detect the deprecated API\nelements.In the case of Scikit-learn, Numpy and Pandas, some of the\nfunctions that are used to deprecate parameters or parameter\nvalues or deprecation warnings induced by other libraries are\nalso captured. Hence, the number of deprecated API elements\ndetected by the algorithm is higher than the actual number of\ndeprecated APIs. Whereas in the case of Scipy and Seaborn,\nsome of the parameters are deprecated without using any of the\nthree deprecation strategies, which could not be detected by\nthe algorithm. Hence, the number of deprecated API elements\ndetected by the algorithm for Scipy and Seaborn are lower\nthan the actual number of deprecated APIs.", "IV. LIMITATIONS AND THREATS TO VALIDITY APIScanner detects deprecated APIs through decorator, warning or comments. Any other deprecated APIs that are not implemented through the above three strategies cannot": "Scikit-learn\nMatplotlib\nNumpy\nPandas\nScipy\nSeaborn\n388.1k\n982.5k\n145.6k\n668.9k\n725.62k\n83.7kTABLE IEVALUATION OF RESULTS OBTAINED USING OUR ALGORITHM\nbe detected by the algorithm. Moreover, the algorithm finds\nthe function or class in which a parameter is deprecated but\nthe exact parameter deprecated may not be mentioned in\nthe deprecation message displayed by the extension due to\nthe inconsistent deprecation strategies adopted by the library\nmaintainers. APIs deprecated without using the\nDeprecationWarning and FutureWarning as parameters in the warning\nfunction cannot be detected by the algorithm. APIs deprecated\nusing single-line comments and not using the doc-strings also\ncannot be detected by the algorithm. Further, a major\nprerequisite for our approach is the availability of source code\nof libraries. We can mitigate the threat due to inconsistent\ndeprecation strategies if we can ensure that the documentation\nis structured and well maintained for Python libraries.Finally, since the results are evaluated manually, there may\nbe human errors. Hence, we have carefully reviewed and\nvalidated some of the results using release notes to mitigate\nthis potential threat. We plan to extend the evaluation of the\ntool using release notes and API documentation.", "V. RELATED WORK": "In the literature, several studies on deprecated APIs for\ndifferent environments have been done to analyze and tackle\nthe challenges posed by the deprecation of APIs in libraries.\n        Robbes et al. [\n        \n        ], [\n        \n        ] studied the reactions of developers\nto the deprecation and the impact of API deprecation on the\nSmalltalk and Pharo ecosystem. Ko et al. [\n        \n        ] examined 260\ndeprecated APIs from eight Java libraries and their\ndocumentation and observed that 61% of deprecated APIs are offered\nwith replacements. Similarly, Brito et al. [\n        \n        ] conducted a\nlarge-scale study on 661 real-world Java systems and found\nthat replacements are provided for 64% of the deprecated\nAPIs. In another study [\n        \n        ] conducted on Java and C# projects,\nthey have observed that an average of 66.7% of APIs in\nJava projects and 77.8% in C# projects were deprecated\nwith replacement messages. In 26 open-source Java systems\nover 690 versions, Zhou et al. [\n        \n        ] analysed the history of\ndeprecated APIs and observed that deprecated API messages\nare not well managed by library contributors with very few\ndeprecated APIs being listed with replacements. Li et al. [\n        \n        ]\ncharacterized the deprecated APIs in Android Apps parsing\nthe code of 10000 Android applications. Zhang et al. [\n        \n        ]\nhave observed a significant difference in evolution patterns\nof Python and Java APIs and also identified 14 patterns in\nwhich Python APIs evolve. Wang et al. [\n        \n        ] observed that\nlibrary contributors do not properly handle API deprecation in\nPython libraries. To this end, there is a need for approaches\nand tools to automatically detect deprecated API elements in\nPython projects.\n      \n        Several approaches have been proposed in the literature for\nother ecosystems to migrate from deprecated APIs [\n        \n        ], [\n        \n        ],\n[\n        \n        ]. Yaoguo Xi et al. [\n        \n        ] proposed an approach and built a\ntool DAAMT to migrate from deprecated APIs in Java to their\nreplacements if recorded in the documentation. Fazzini et al.\n[\n        \n        ] developed a technique AppEvolve to update API changes in\nAndroid Apps by automatically learning from examples before\nand after-updates. Haryono et al. [\n        \n        ] proposed an approach\nnamed CocciEvolve that updates using only a single\nafterupdate example. However, tools that handle deprecated APIs\nin Python projects have not been developed, which motivated\nus towards the development of APIScanner.\n      ", "VI. CONCLUSION AND FUTURE WORK": "Considering the extensive use of deprecated APIs during\nsoftware development and lack of proper documentation for\ndeprecated APIs, we proposed an approach to automatically\ndetect deprecated APIs in Python libraries during the\ndevelopment phase of the project. In this paper, we presented a\nnovel algorithm and a tool called APIScanner that detects\ndeprecated APIs. The algorithm identifies the APIs deprecated\nvia decorator, hard-coded warning or comments by parsing the\nsource code of the libraries and generated a list of deprecated\nAPIs. APIScanner used this list and searched for the use of\ndeprecated APIs in the current active editor. The tool\nhighlights deprecated APIs in the source code along with further\ndeprecation details. APIScanner thus aims to help developers\ndetect deprecated APIs during the development stage and avoid\nsearching through API documentation or forums such as Stack\nOverflow. Highlighting the use of deprecated APIs in the\neditor might help developers to address and replace them. The\nproposed algorithm identified 838 out of 871 API elements\nacross six different Python libraries.As future work, our goal is to strengthen the tool with\nrelease-specific information and develop a better user interface\n(such as different colors) to indicate the severity of the\ndeprecation. We also plan to improve the documentation of\ndeprecated APIs through the information obtained from the\nalgorithm. We plan to extend the tool to provide a feature\nto migrate from the deprecated API to its replacement. We\naim to improve the tool?s accuracy by extracting APIs that are\ndeprecated using the custom deprecation strategies. Finally, we\nplan to conduct extensive developer studies on the usage of\nthe approach and the tool with more libraries."}